## TODO: Section Title

Back in Chapter 16, we saw an example of counting up on multiple threads. Given
that threads allow us to implement a form of concurrency, we might expect that
async APIs can substitute fairly directly for the threading APIs. The `trpl`
crate supplies a `spawn_task` function which looks very similar to the
`thread::spawn` API, and a `sleep` function which is an async version of the
`thread::sleep` API. We can use these together to implement the same counting
example as with threads:

<!--
    TODO: this needs some bridging text/connective tissue explaining what we are
      actually writing here, since it is not *identical*
-->

<Listing number="17-TODO" caption="Showing how we might implement two counters with `async` instead of threads" file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch17-async-await/listing-TODO-01/src/main.rs}}
```

</Listing>

This does something very similar to what the thread-base implementation did, as
we can see from the output:

```text
hi number 1 from the second task!
hi number 1 from the first task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
```

Just like with the threading example, you may see a different order in your own
terminal output when you run this. And, just like the threading example, if you
want to run all the way to the completion of the first task, you will need to
use a join handle to wait for the first task to complete. With threads, we used
the `join` method to “block” until the thread was done running. Here, we can use
`await` to do the same thing:

<!-- TODO: extract into listing, just getting it “onto the page” for now -->

```rust
use std::time::Duration;

fn main() {
    trpl::block_on(async {
        let handle = trpl::spawn_task(async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(1)).await;
            }
        });

        for i in 1..5 {
            println!("hi number {i} from the second task!");
            trpl::sleep(Duration::from_millis(1)).await;
        }

        handle.join().await
    });
}
```

Now the output again matches

```text
hi number 1 from the second task!
hi number 1 from the first task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
hi number 6 from the first task!
hi number 7 from the first task!
hi number 8 from the first task!
hi number 9 from the first task!
```

<!-- TODO: discuss tasks vs. threads more here? -->

<!-- TODO: when we drop the `trpl::spawn_task` and use native futures… -->

```text
hi number 1 from the first task!
hi number 1 from the second task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
hi number 6 from the first task!
hi number 7 from the first task!
hi number 8 from the first task!
hi number 9 from the first task!
```

Here, at least with the implementation we are using in `trpl`, you will see
the exact same order every time, which is *very* different from what we saw with
threads.

